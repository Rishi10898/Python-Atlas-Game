import { useEffect, useRef, useState, useCallback } from 'react';
import { Player, PowerUp, GameState, GameConfig } from '@/types/colorTag';
import { 
  checkCollision, 
  movePlayer, 
  handlePlayerCollision,
  getArenaWalls,
  spawnPowerUp,
  checkWinner
} from '@/utils/colorTagLogic';
import { Button } from '@/components/ui/button';
import { toast } from 'sonner';

interface ColorTagCanvasProps {
  config: GameConfig;
  onBackToMenu: () => void;
}

const CANVAS_WIDTH = 900;
const CANVAS_HEIGHT = 650;
const PLAYER_SPEED = 4;
const COLORS = ['#ef4444', '#3b82f6', '#22c55e', '#eab308', '#a855f7'];

export const ColorTagCanvas = ({ config, onBackToMenu }: ColorTagCanvasProps) => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const [gameState, setGameState] = useState<GameState>(() => {
    const walls = getArenaWalls(config.arena, CANVAS_WIDTH, CANVAS_HEIGHT);
    const players: Player[] = [];
    
    for (let i = 0; i < config.playerCount; i++) {
      const angle = (i / config.playerCount) * Math.PI * 2;
      const radius = Math.min(CANVAS_WIDTH, CANVAS_HEIGHT) * 0.35;
      players.push({
        id: i,
        position: {
          x: CANVAS_WIDTH / 2 + Math.cos(angle) * radius,
          y: CANVAS_HEIGHT / 2 + Math.sin(angle) * radius
        },
        velocity: { x: 0, y: 0 },
        color: COLORS[i],
        teamId: i,
        isOriginal: true,
        speed: PLAYER_SPEED,
        invincible: false,
        invincibleUntil: 0
      });
    }

    return {
      players,
      powerUps: [],
      walls,
      gameTime: config.duration,
      isRunning: true,
      winner: null
    };
  });

  const keysPressed = useRef<Set<string>>(new Set());
  const lastPowerUpSpawn = useRef(Date.now());

  const playSound = (frequency: number, duration: number) => {
    const audioContext = new AudioContext();
    const oscillator = audioContext.createOscillator();
    const gainNode = audioContext.createGain();
    
    oscillator.connect(gainNode);
    gainNode.connect(audioContext.destination);
    oscillator.frequency.value = frequency;
    gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
    
    oscillator.start();
    oscillator.stop(audioContext.currentTime + duration);
  };

  const drawGame = useCallback(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    ctx.fillStyle = '#0f172a';
    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

    // Draw walls
    ctx.fillStyle = '#334155';
    gameState.walls.forEach(wall => {
      ctx.fillRect(wall.x, wall.y, wall.width, wall.height);
      ctx.strokeStyle = '#475569';
      ctx.lineWidth = 2;
      ctx.strokeRect(wall.x, wall.y, wall.width, wall.height);
    });

    // Draw power-ups
    gameState.powerUps.forEach(powerUp => {
      if (!powerUp.active) return;
      
      const icons = { speed: '‚ö°', shield: 'üõ°Ô∏è', freeze: '‚ùÑÔ∏è', teleport: '‚ú®' };
      ctx.fillStyle = '#fbbf24';
      ctx.beginPath();
      ctx.arc(powerUp.position.x, powerUp.position.y, 18, 0, Math.PI * 2);
      ctx.fill();
      ctx.font = '20px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(icons[powerUp.type], powerUp.position.x, powerUp.position.y);
    });

    // Draw players
    const now = Date.now();
    gameState.players.forEach(player => {
      const isInvincible = player.invincible && player.invincibleUntil > now;
      
      if (isInvincible && Math.floor(now / 100) % 2 === 0) {
        ctx.globalAlpha = 0.5;
      }

      ctx.fillStyle = player.color;
      ctx.beginPath();
      ctx.arc(player.position.x, player.position.y, 15, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.strokeStyle = player.isOriginal ? '#fbbf24' : '#ffffff';
      ctx.lineWidth = player.isOriginal ? 4 : 2;
      ctx.stroke();

      if (player.isOriginal) {
        ctx.fillStyle = '#fbbf24';
        ctx.font = 'bold 20px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('üëë', player.position.x, player.position.y - 25);
      }

      ctx.globalAlpha = 1;
    });
  }, [gameState]);

  const updateGame = useCallback(() => {
    if (!gameState.isRunning) return;

    setGameState(prev => {
      let newPlayers = [...prev.players];
      const now = Date.now();

      // Update velocities based on input
      newPlayers = newPlayers.map(player => {
        let vx = 0, vy = 0;
        
        if (player.id === 0) {
          if (keysPressed.current.has('w')) vy -= player.speed;
          if (keysPressed.current.has('s')) vy += player.speed;
          if (keysPressed.current.has('a')) vx -= player.speed;
          if (keysPressed.current.has('d')) vx += player.speed;
        } else if (player.id === 1) {
          if (keysPressed.current.has('arrowup')) vy -= player.speed;
          if (keysPressed.current.has('arrowdown')) vy += player.speed;
          if (keysPressed.current.has('arrowleft')) vx -= player.speed;
          if (keysPressed.current.has('arrowright')) vx += player.speed;
        }

        return { ...player, velocity: { x: vx, y: vy } };
      });

      // Move players
      newPlayers = newPlayers.map(player => 
        movePlayer(player, prev.walls, CANVAS_WIDTH, CANVAS_HEIGHT)
      );

      // Check collisions
      for (let i = 0; i < newPlayers.length; i++) {
        for (let j = i + 1; j < newPlayers.length; j++) {
          if (checkCollision(newPlayers[i].position, newPlayers[j].position)) {
            const converted1 = handlePlayerCollision(newPlayers[i], newPlayers[j], now);
            const converted2 = handlePlayerCollision(newPlayers[j], newPlayers[i], now);
            
            if (converted1) {
              newPlayers[j] = converted1;
              playSound(600, 0.15);
              toast.success(`Player ${i + 1} converted Player ${j + 1}!`);
            }
            if (converted2) {
              newPlayers[i] = converted2;
              playSound(600, 0.15);
              toast.success(`Player ${j + 1} converted Player ${i + 1}!`);
            }
          }
        }
      }

      // Check power-up collection
      const activePowerUps = prev.powerUps.filter(powerUp => {
        if (!powerUp.active) return false;
        
        for (const player of newPlayers) {
          if (checkCollision(player.position, powerUp.position)) {
            playSound(800, 0.2);
            toast.info(`Power-up collected!`);
            return false;
          }
        }
        return true;
      });

      // Spawn new power-ups
      if (now - lastPowerUpSpawn.current > 5000 && activePowerUps.length < 3) {
        const types: PowerUp['type'][] = ['speed', 'shield', 'freeze', 'teleport'];
        activePowerUps.push({
          id: Math.random().toString(),
          position: spawnPowerUp(prev.walls, CANVAS_WIDTH, CANVAS_HEIGHT),
          type: types[Math.floor(Math.random() * types.length)],
          active: true
        });
        lastPowerUpSpawn.current = now;
      }

      // Check winner
      const winner = checkWinner(newPlayers);
      if (winner !== null) {
        playSound(523, 0.8);
        toast.success(`Team ${winner + 1} wins!`, { duration: 5000 });
        return { ...prev, players: newPlayers, isRunning: false, winner };
      }

      return { ...prev, players: newPlayers, powerUps: activePowerUps };
    });
  }, [gameState.isRunning]);

  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      keysPressed.current.add(e.key.toLowerCase());
    };

    const handleKeyUp = (e: KeyboardEvent) => {
      keysPressed.current.delete(e.key.toLowerCase());
    };

    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);

    const gameLoop = setInterval(() => {
      updateGame();
      drawGame();
    }, 1000 / 60);

    const timer = setInterval(() => {
      if (gameState.isRunning && gameState.gameTime > 0) {
        setGameState(prev => {
          const newTime = prev.gameTime - 1;
          if (newTime === 0) {
            toast.info('Time up! Most players win!');
            return { ...prev, gameTime: 0, isRunning: false };
          }
          return { ...prev, gameTime: newTime };
        });
      }
    }, 1000);

    return () => {
      window.removeEventListener('keydown', handleKeyDown);
      window.removeEventListener('keyup', handleKeyUp);
      clearInterval(gameLoop);
      clearInterval(timer);
    };
  }, [updateGame, drawGame, gameState.isRunning, gameState.gameTime]);

  return (
    <div className="min-h-screen flex flex-col items-center justify-center bg-gradient-to-br from-slate-900 via-purple-900 to-slate-900 p-4 gap-4">
      <div className="flex items-center justify-between w-full max-w-[900px]">
        <Button onClick={onBackToMenu} variant="outline" size="lg">
          ‚Üê Menu
        </Button>
        <div className="text-3xl font-black text-white">
          ‚è±Ô∏è {gameState.gameTime}s
        </div>
        <div className="flex gap-3">
          {Array.from(new Set(gameState.players.map(p => p.teamId))).map(teamId => {
            const count = gameState.players.filter(p => p.teamId === teamId).length;
            const color = gameState.players.find(p => p.teamId === teamId)?.color;
            return (
              <div key={teamId} className="flex items-center gap-2 bg-background/20 backdrop-blur px-3 py-2 rounded-lg">
                <div className="w-6 h-6 rounded-full" style={{ backgroundColor: color }} />
                <span className="text-white font-bold">√ó{count}</span>
              </div>
            );
          })}
        </div>
      </div>

      <canvas
        ref={canvasRef}
        width={CANVAS_WIDTH}
        height={CANVAS_HEIGHT}
        className="border-4 border-purple-500 rounded-xl shadow-2xl shadow-purple-500/50"
      />

      {!gameState.isRunning && gameState.winner !== null && (
        <div className="text-center">
          <h2 className="text-5xl font-black text-white mb-4">
            üéâ TEAM {gameState.winner + 1} WINS! üéâ
          </h2>
          <Button onClick={onBackToMenu} size="lg" className="text-xl">
            Play Again
          </Button>
        </div>
      )}
    </div>
  );
};
